using System.Collections; using System.Collections.Generic; using UnityEngine; using UnityEngine.UI;  public class Player2 : MonoBehaviour {     public string[] animType;     Animator animator;     public GameObject P1HP;     public GameObject attackEffect;     public GameObject getEffect;     public bool pause = false;     public float speed;     public AttackMode currentAttackMode;     int hp;      /// <summary>     /// 操作モード     /// </summary>     public enum ControlMode     {         Human, // 人間         AI     // AI     }      public enum AttackMode     {         Attack, // 人間         Tornade,// AI         Combo,         Cutin     }      public ControlMode Mode = ControlMode.AI;      /// <summary>     /// 攻撃状態ならtrue     /// </summary>     public bool IsAttacking;      /// <summary>     /// ダメージ状態ならtrue     /// </summary>     public bool IsDamaged;      /// <summary>     /// 死んだらtrue     /// </summary>     public bool IsDead;      /// <summary>     /// 敵     /// </summary>     [SerializeField]     Player1 Enemy;      //自分のHPバー     public GameObject hpbar;      // Use this for initialization     void Start()     {         animator = GetComponent<Animator>();     }      private void OnEnable()    {         if (Mode == ControlMode.AI){             StartCoroutine("Attack");         }      }   // Update is called once per frame  void Update()     {         animator.SetBool("damage", IsDamaged);          //ダメージを受けていたら何もしない         if (IsDamaged)             return;          //死んでたら何もしない         if (IsDead)             return;         if(pause){             return;         }          switch( Mode )         {             case ControlMode.Human:                 var h = Input.GetAxis("Horizontal2");                 var v = Input.GetAxis("Vertical2");                 Vector2 direction = new Vector2(h, v).normalized;                  // 移動する向きとスピードを代入                  GetComponent<Rigidbody2D>().velocity = direction * speed;                   if (Input.GetButtonDown("Attack2"))                 {                     Debug.Log("Attack2");                     animator.SetTrigger("attack");                     currentAttackMode = AttackMode.Attack;                 }                  if (Input.GetButtonDown("Tornade2"))                 {                     Debug.Log("Tornade2");                     animator.SetTrigger("tornade");                     currentAttackMode = AttackMode.Tornade;                 }                 if (Input.GetButtonDown("Combo2"))                 {                     Debug.Log("Combo2");                     animator.SetTrigger("combo");                     currentAttackMode = AttackMode.Combo;                 }                 if (Input.GetButtonDown("Cutin2"))                 {                     Debug.Log("Cutin2");                     currentAttackMode = AttackMode.Cutin;                                     }                                  break;              case ControlMode.AI:                 Vector3 diff = transform.position - Enemy.transform.position;                  if (diff.x > +1)                     transform.position += Vector3.left * 0.05f;                 else                 if (diff.x < -1)                     transform.position += Vector3.right * 0.05f;                 break;           }     }       // コルーチン       private IEnumerator Attack()     {         // コルーチンの処理           while (!IsDead)         {             float waitTime = Random.Range(1.0f, 2.0f);             yield return new WaitForSeconds(waitTime);              int animIndex = Random.Range(0, animType.Length);             // Debug.Log(animType[animIndex]);              animator.SetBool(animType[animIndex], true);         }     }      //ダメージを受ける     public void Damage()     {         //  既にダメージを受けていたら何もしない         if (IsDamaged)             return;          //死んでたら何もしない         if (IsDead)             return;                  // Debug.Log("Player 2 Damaged!");          IsDamaged = true;         Debug.Log("StartCoroutine damaged");         StartCoroutine(damaged());          P1HP.GetComponent<SetSpriteToHP>().addHP();          //コピーして表示         Instantiate(attackEffect, gameObject.transform.position, Quaternion.identity);     }      // ダメージを受けたフラグを管理するコルーチン       private IEnumerator damaged()     {         Debug.Log("damaged started");         // n秒待機してから、ダメージ状態を解除する         yield return new WaitForSeconds(1.0f);         Debug.Log("damaged 1");         IsDamaged = false;         Debug.Log("damaged 2");     }      //ダメージを受けました     void OnCollisionStay2D(Collision2D col)     {         if (col.gameObject != Enemy.gameObject)             return;          //ダメージ中は追加ダメージを受けない         if (IsDamaged)             return;          //死んでいたらダメージはない         if (IsDead)             return;                  //敵が攻撃中ではないなら、ダメージにはならない         if (!Enemy.IsAttacking)             return;          Player1.AttackMode enemyMode = Enemy.GetComponent<Player1>().currentAttackMode;         switch ( enemyMode){             case Player1.AttackMode.Attack:                 switch( currentAttackMode){                     case Player2.AttackMode.Attack:                         damaged(1);                         break;                     case Player2.AttackMode.Combo:                         damaged(8);                         break;                     case Player2.AttackMode.Tornade:                         damaged(3);                         break;                     case Player2.AttackMode.Cutin:                         break;                     default:                         break;                 }                 break;             case Player1.AttackMode.Combo:                 switch (currentAttackMode)                 {                     case Player2.AttackMode.Attack:                         damaged(3);                         break;                     case Player2.AttackMode.Combo:                         damaged(1);                         break;                     case Player2.AttackMode.Tornade:                         damaged(8);                         break;                     case Player2.AttackMode.Cutin:                         break;                     default:                         break;                 }                 break;             case Player1.AttackMode.Tornade:                 switch (currentAttackMode)                 {                     case Player2.AttackMode.Attack:                         damaged(8);                         break;                     case Player2.AttackMode.Combo:                         damaged(3);                         break;                     case Player2.AttackMode.Tornade:                         damaged(1);                         break;                     case Player2.AttackMode.Cutin:                         break;                     default:                         break;                 }                 break;             case Player1.AttackMode.Cutin:                 switch (currentAttackMode)                 {                     case Player2.AttackMode.Attack:                         break;                     case Player2.AttackMode.Combo:                         break;                     case Player2.AttackMode.Tornade:                         break;                     case Player2.AttackMode.Cutin:                         break;                     default:                         break;                 }                 break;                      }            // damaged(3);          if (hp > 0)         {             Damage();         }         else         {             //HPが０以下なので、「そこまで！」             GameManager.Instance.GameSet(1);             animator.SetBool("die", true);         }      }      public void damaged(int v)     {         var slider = hpbar.GetComponent<Slider>();         hp = (int)slider.value;         hp -= v;         slider.value = hp;     }     private void OnCollisionEnter2D(Collision2D coll)     {          if (coll.gameObject.tag == "Star")         {             Instantiate(getEffect, coll.gameObject.transform.position, Quaternion.identity);              Destroy(coll.gameObject);         }        } }   // http://developer.wonderpla.net/entry/blog/engineer/Unity_Co-routine/ 